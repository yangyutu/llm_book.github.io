
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>21. RAG &#8212; LLM Foundations</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css?v=ca93fcec" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'docs/chapter_rag/basic_rag';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="22. Advanced RAG (WIP)" href="advanced_rag.html" />
    <link rel="prev" title="20. Advanced Prompting Techniques" href="../chapter_prompt/advanced_prompt.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/qe-logo-large.png" class="logo__image only-light" alt="LLM Foundations - Home"/>
    <script>document.write(`<img src="../../_static/qe-logo-large.png" class="logo__image only-dark" alt="LLM Foundations - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">1. Introduction: LLM in the Age of AI</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">LLM Foundations</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapter_foundation/language_models.html">2. Language Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_foundation/neural_language_models.html">3. Early Neural Language Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_foundation/word_embeddings.html">4. Word Embeddings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_foundation/transformers.html">5. Transformers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_foundation/bert.html">6. BERT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_foundation/t5.html">7. Seq2Seq: T5 and BART</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_foundation/GPT_series.html">8. GPT Series</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">LLM Architectures</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapter_LLM_arch/LLM_dense_architectures.html">9. LLM Architectures Fundamentals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/chapter_LLM_arch/annotated_llama.html">10. *Annotated LLama</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_LLM_arch/LLM_moe_sparse_architectures.html">11. MOE Sparse Architectures (WIP)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">LLM Training</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapter_training/training_fundamentals.html">12. LLM Training Fundamentals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_training/finetuning.html">13. LLM Finetuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_training/alignment.html">14. LLM Alignement and Preference Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_training/reinforcement_learning.html">15. *Reinforcement Learning Essentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_training/accelerated_training.html">16. LLM Training Acceleration (WIP)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">LLM Inference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapter_inference/inference_fundamentals.html">17. Decoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_inference/inference_acceleration.html">18. Inference Acceleration (WIP)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Prompting</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapter_prompt/basic_prompt.html">19. Basic Prompting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_prompt/advanced_prompt.html">20. Advanced Prompting Techniques</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">RAG and Agents</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">21. RAG</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced_rag.html">22. Advanced RAG (WIP)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Application in Information Retrieval</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapter_application_IR/information_retrieval_fundamentals.html">23. Information Retrieval and Text Ranking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_application_IR/application_LLM_in_IR.html">24. Application of LLM in IR (WIP)</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>RAG</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#motivation">21.1. Motivation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-frameworks">21.2. RAG Frameworks</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-rag">21.2.1. Basic RAG</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimizations">21.2.2. RAG Optimizations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-challenges-in-practice">21.2.3. RAG Challenges in Practice</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-evaluation">21.3. RAG Evaluation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimization-documents">21.4. RAG Optimization: Documents</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#indexing-data-sources">21.4.1. Indexing Data Sources</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#document-parsing">21.4.2. Document Parsing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#data-source-augmentation">21.4.3. Data Source Augmentation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#document-splitting-and-granularity">21.4.4. Document Splitting and Granularity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#document-chunk-relationship">21.4.5. Document Chunk Relationship</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#utilizing-knowledge-graph">21.4.6. Utilizing Knowledge Graph</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fundamentals">21.4.6.1. Fundamentals</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#challenges">21.4.6.2. Challenges</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimization-query-understanding-and-rewriting">21.5. RAG Optimization: Query Understanding and Rewriting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">21.5.1. Motivation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#approach-to-vocalbulary-mismatch">21.5.2. Approach to Vocalbulary Mismatch</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#approach-to-complex-multi-concept-queries">21.5.3. Approach to Complex Multi-Concept Queries</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#approach-to-multi-turn-conversations">21.5.4. Approach to Multi-Turn Conversations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced-query-categorization">21.5.5. Advanced Query Categorization</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimization-retriever-and-reranker">21.6. RAG Optimization: Retriever and ReRanker</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#retrieval-model-enhancement">21.6.1. Retrieval Model Enhancement</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#retrieval-result-quality-control">21.6.2. Retrieval Result Quality Control</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimization-llm-understanding-generation">21.7. RAG Optimization: LLM Understanding &amp; Generation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#motivation-and-objective">21.7.1. Motivation and Objective</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#prompting">21.7.2. Prompting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#model-finetuning">21.7.3. Model Finetuning</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#raft-retrieval-augmented-fine-tuning">21.7.4. RAFT: Retrieval Augmented Fine Tuning</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-rag-discussion">21.8. Further RAG Discussion</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-vs-prompting-and-fine-tuning">21.8.1. RAG vs Prompting and Fine Tuning</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-vs-long-context-llm">21.8.2. RAG vs Long Context LLM</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bibliography">21.9. Bibliography</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="rag">
<h1><span class="section-number">21. </span>RAG<a class="headerlink" href="#rag" title="Link to this heading">#</a></h1>
<section id="motivation">
<h2><span class="section-number">21.1. </span>Motivation<a class="headerlink" href="#motivation" title="Link to this heading">#</a></h2>
<p>LLMs have revolutionized natural language processing, but they still face several significant challenges, particularly in <strong>knowledge intensive tasks</strong>:</p>
<ul class="simple">
<li><p><strong>Hallucination</strong>: LLMs can generate plausible-sounding but factually incorrect information when they are prompted with rare or ambiguous queries, e.g., what is kuula? (a fishing god). And there lacks an intrinsic way of detecting when LLM is making up facts.</p></li>
<li><p><strong>Outdated and publically-sourced knowledge</strong>: The knowledge of off-the-shelf LLMs is usually limited to their publically-sourced pre-training data, which can quickly become obsolete. LLM cannot answer questions like stock market values, weather forecast, news, etc. that require access to dynamic, ever-changing knowledge; neither can LLM answer questions related to private company documents not used in training data.</p></li>
<li><p><strong>Untraceable reasoning</strong>: The decision-making process of LLMs is often unclear, making it difficult to verify or understand their outputs.</p></li>
<li><p><strong>Expensive cost to inject knowledge</strong>: Although one can inject domain knowledge or updated knowledge via continuous pretraining or finetining, the cost of data collections and training is very high.</p></li>
</ul>
<p>To address these challenges, researchers and developers have been exploring promising solutions. One such solution is to integrate of LLMs’ inherent knowledge with external knowledge bases during model generation process. This approach is known as <strong>Retrieval-Augmented Generation (RAG)</strong> [<a class="reference internal" href="#chapter-rag-fig-rag-demo"><span class="std std-numref">Fig. 21.1</span></a>].</p>
<figure class="align-default" id="chapter-rag-fig-rag-demo">
<a class="reference internal image-reference" href="../../_images/RAG_demo.png"><img alt="../../_images/RAG_demo.png" src="../../_images/RAG_demo.png" style="width: 712.1999999999999px; height: 414.0px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.1 </span><span class="caption-text">Illustration of RAG process applied to question answering. It mainly consists of basic steps. 1) Offline Indexing. Documents are collected and split into chunks,
encoded into vectors, and stored in a vector database. 2) Retrieval. Retrieve the Top <span class="math notranslate nohighlight">\(k\)</span> relevant chunks as context or knowledge supplement. 3)
Generation. The original question and the retrieved context are fed into LLM to generate the final answer. Image from <span id="id1">[<a class="reference internal" href="#id1549" title="Yunfan Gao, Yun Xiong, Xinyu Gao, Kangxiang Jia, Jinliu Pan, Yuxi Bi, Yi Dai, Jiawei Sun, and Haofen Wang. Retrieval-augmented generation for large language models: a survey. arXiv preprint arXiv:2312.10997, 2023.">GXG+23</a>]</span>.</span><a class="headerlink" href="#chapter-rag-fig-rag-demo" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Compared to LLM’s responses that are relied on its own internal knowledge, RAG exhibits the following advantages:</p>
<ul class="simple">
<li><p><strong>Improved accuracy and reliability</strong>: By supplementing the LLM’s knowledge with current, factual information from external sources, RAG can significantly reduce hallucinations and increase the accuracy of generated content. In additional, by comparing retrieved sources and generated output, one can trace or verify claims in the output.</p></li>
<li><p><strong>Superior performance on knowledge-intensive tasks</strong>: RAG excels in tasks that require specific, detailed information, such as question-answering, fact-checking, and research assistance.</p></li>
<li><p><strong>Continuous and domain-specific knowledge updates</strong>: Unlike traditional LLMs, which require retraining or continuous pretraining to incorporate updated or additional information, RAG systems can be updated by simply modifying the external knowledge base. This allows for more frequent and efficient knowledge updates and the integration of specialized knowledge from particular fields or industries, making it possible to create more focused and accurate outputs for specific domains.</p></li>
</ul>
</section>
<section id="rag-frameworks">
<h2><span class="section-number">21.2. </span>RAG Frameworks<a class="headerlink" href="#rag-frameworks" title="Link to this heading">#</a></h2>
<section id="basic-rag">
<h3><span class="section-number">21.2.1. </span>Basic RAG<a class="headerlink" href="#basic-rag" title="Link to this heading">#</a></h3>
<p>RAG is a technique that combines the powerful language understanding generation capabilities of LLMs with the information retrieval ability of a retrieval system/search engine. This hybrid approach aims to leverage the strengths of both systems to produce more accurate, up-to-date, and verifiable outputs.</p>
<p>The <strong>RAG</strong> framework is built upon four fundamental components [<a class="reference internal" href="#chapter-rag-fig-rag-framework-demo"><span class="std std-numref">Fig. 21.2</span></a>]:</p>
<ul class="simple">
<li><p><strong>Data Collection</strong>, which involves the collection of public or private data relevant to the domain of interest. Data can come from a large variety of sources and from different modalities.</p></li>
<li><p><strong>Indexing building</strong>, which transforms data source into a format that enables efficient retrieval and knowledge integration. For example, one can split a document into multiple chunks, and encode each of them into dense embedding vectors (for dense retrieval) or inverted index (for sparse retrieval). Indexing building is usually done offline.</p></li>
<li><p><strong>Retrieval</strong>, which is the process of extracting relevant paragraph/chunks from the index in response to a query. This step involves online query understanding and processing - transform the query into embedding vector (for dense retrieval) or terms (for sparse retrieval) and retrieving documents using query vectors or terms.</p></li>
<li><p><strong>Generation</strong>, which involves using the retrieved information along with the language model’s inherent knowledge to produce a response. This step leverages the power of large language models to understand context, integrate the retrieved information, and generate coherent and relevant text.</p></li>
</ul>
<figure class="align-default" id="chapter-rag-fig-rag-framework-demo">
<a class="reference internal image-reference" href="../../_images/Basic_RAG_framework.png"><img alt="../../_images/Basic_RAG_framework.png" src="../../_images/Basic_RAG_framework.png" style="width: 388.5px; height: 514.5px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.2 </span><span class="caption-text">Illustration of a basic RAG framework.</span><a class="headerlink" href="#chapter-rag-fig-rag-framework-demo" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="proof example admonition" id="example-0">
<p class="admonition-title"><span class="caption-number">Example 21.1 </span> (A minimal RAG example)</p>
<section class="example-content" id="proof-content">
<p>The Vanilla RAG (Retrieval-Augmented Generation) operates in a simplified manner as follows:</p>
<ul class="simple">
<li><p>The text is divided into chunks.</p></li>
<li><p>These chunks are then encoded into vectors using a Transformer encoder model, and all these vectors are stored in a vector database.</p></li>
<li><p>Finally, a Language Model (LLM) prompt is created, and the model answers user queries based on the context retrieved from the top-k most relevant results found through vector indexing in the vector database.</p></li>
</ul>
<p>During interaction, the same encoder model is used to vectorize user queries. Vector indexing is then performed to identify the top-k most relevant results from the vector database. These indexed text chunks are retrieved and provided as context to the LLM prompt for generating responses to user queries.</p>
<p><em>Example LLM prompt</em>:</p>
<p>Give the answer to the user query delimited by triple backticks <code class="docutils literal notranslate"><span class="pre">{query}</span></code> using the information given in context delimited by triple backticks <code class="docutils literal notranslate"><span class="pre">{context}</span></code>. If there is no relevant information in the provided context, try to answer yourself, but tell user that you did not have any relevant context to base your answer on. Be concise and output the answer of size less than 80 tokens.</p>
</section>
</div></section>
<section id="rag-optimizations">
<h3><span class="section-number">21.2.2. </span>RAG Optimizations<a class="headerlink" href="#rag-optimizations" title="Link to this heading">#</a></h3>
<p>Various optimizations can be applied to the basic RAG framework [<a class="reference internal" href="#chapter-rag-fig-rag-framework-demo"><span class="std std-numref">Fig. 21.2</span></a>] to improve the quality and reliability of the system’s outputs. These optimizations address common challenges in RAG systems, including query-document mismatch, retrieval accuracy, and output reliability.</p>
<p>As shown in <a class="reference internal" href="#chapter-rag-fig-rag-framework-optimization-demo"><span class="std std-numref">Fig. 21.3</span></a>, we can divide optimizations into the following categories:</p>
<p><strong>Document Understanding &amp; Augmentation</strong>:Instead of performing mechanism chunking to split the document, we can apply language understanding models to split documents into semnatically coherent units. Besides, we can enriches documents with additional context, metadata (e.g., stamptime), and alternative representations (e.g., summaries, queries related to document) before they enter the indexing phase. This enrichment makes documents more discoverable and helps maintain their semantic context even when they are split into chunks for processing.</p>
<p><strong>Query Understanding and Rewriting</strong>: This enhancement addresses one of the fundamental challenges in information retrieval: the vocabulary mismatch between query language and document language. The system can employ LLM to analyze and reformulate user queries, making them more effective for retrieval. It can help complex, multi-concept queries by decomposing the original query into multiple manageable subqueries.</p>
<p><strong>Hybrid retrieval</strong>: Instead of using only sparse retrieval or dense retrieval, one can combine them together to form a hybrid retrieval system. For example, encoder models used in dense retriever can produce additional features for rankers in the sparse retriever side.</p>
<p><strong>Re-ranking for quality control</strong>: After the initial retrieval, the Re-ranking step can significantly improves the quality and precision of retrieved content before it reaches the LLM. Documents are re-ranked using a much powerful model based on their contextual relevance to the user query, not just the vector semantic similarity. In addition, the re-ranking process can use extra rules to penalize similiar documents to promote a diverse set of relevant documents are sent to LLM.</p>
<p><strong>LLM Understanding &amp; Generation</strong>：Even with high-quality inputs to LLM, LLM can still produce poor results. This can be alleviated by improving model size, pretraining data quality and distribution, and fine-tuning strategies.</p>
<p><strong>Output verification</strong>: As the final layer quality control, after the LLM’s output, we can add an additional step to validates the LLM’s output against the retrieved and re-ranked sources. This final check ensures accuracy and consistency.</p>
<figure class="align-default" id="chapter-rag-fig-rag-framework-optimization-demo">
<a class="reference internal image-reference" href="../../_images/Basic_RAG_framework_optimization.png"><img alt="../../_images/Basic_RAG_framework_optimization.png" src="../../_images/Basic_RAG_framework_optimization.png" style="width: 388.5px; height: 493.49999999999994px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.3 </span><span class="caption-text">Optimization of the basic RAG framework in different components.</span><a class="headerlink" href="#chapter-rag-fig-rag-framework-optimization-demo" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="rag-challenges-in-practice">
<h3><span class="section-number">21.2.3. </span>RAG Challenges in Practice<a class="headerlink" href="#rag-challenges-in-practice" title="Link to this heading">#</a></h3>
<p>The following key factors are essential to a successful application of RAG in real-world. These four keys are sequentially dependent and any issues on one-of-them will cause response of poor quality.</p>
<figure class="align-default" id="chapter-rag-fig-rag-framework-key-success-factors">
<a class="reference internal image-reference" href="../../_images/RAG_key_success_factors.png"><img alt="../../_images/RAG_key_success_factors.png" src="../../_images/RAG_key_success_factors.png" style="width: 767.55px; height: 74.55px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.4 </span><span class="caption-text">Key factors underlying a successful RAG product.</span><a class="headerlink" href="#chapter-rag-fig-rag-framework-key-success-factors" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Following table summarize practical challenges and possible causes when applying RAG into actual product.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Issue Type</p></th>
<th class="head"><p>Document Understanding</p></th>
<th class="head"><p>Query Understanding &amp; Ranking Service</p></th>
<th class="head"><p>LLM</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Hallucination</p></td>
<td><p>Chunking, truncation, text extraction errors, incomplete</p></td>
<td><p></p></td>
<td><p>Model generate hallucination</p></td>
</tr>
<tr class="row-odd"><td><p>Refusal to Answer</p></td>
<td><p></p></td>
<td><p>Search results irrelevant &amp; incomplete</p></td>
<td><p>Model not understanding content</p></td>
</tr>
<tr class="row-even"><td><p>Incomplete Response</p></td>
<td><p>Incomplete chunking</p></td>
<td><p>Search results irrelevant &amp; incomplete</p></td>
<td><p>Model summary incomplete</p></td>
</tr>
<tr class="row-odd"><td><p>Slow Response Time</p></td>
<td><p></p></td>
<td><p>Search too slow</p></td>
<td><p>Large model parameters</p></td>
</tr>
</tbody>
</table>
</div>
<!-- ## RAG paradigam overview


% https://arxiv.org/pdf/2312.10997
 -->
</section>
</section>
<section id="rag-evaluation">
<h2><span class="section-number">21.3. </span>RAG Evaluation<a class="headerlink" href="#rag-evaluation" title="Link to this heading">#</a></h2>
<p>Evaluation and benchmarking are crucial steps for RAG development. You cannot improve something you cannot measure it.</p>
<p>RAG application evaluation consists of two facets:</p>
<ul class="simple">
<li><p><strong>Retrieval Evaluation</strong>, which evaluates</p>
<ul>
<li><p><strong>Context relevance</strong> between the retrieved sources and the query, which can be further measured by ranking metrics like recall, precision, and nDCG.</p></li>
<li><p><strong>Diversity</strong> of retrieved sources.</p></li>
</ul>
</li>
<li><p><strong>Response Evaluation</strong>, which evaluates if the final LLM response:</p>
<ul>
<li><p><strong>Consistence &amp; faithfulness</strong>: Be consistent with retrieved context - if the answer is faithful to the retrieved contexts (in other words, whether if there’s hallucination).</p></li>
<li><p><strong>Relevance</strong> Whether the generated answer is relevant to the query.</p></li>
<li><p><strong>Correctness &amp; usefulness</strong> Addresses the information need of the query and being useful (if the query is an information seeking query).</p></li>
<li><p>Other dimensions</p>
<ul>
<li><p>(Expected Style) has expected style (like conciseness, clarity for summary type applications)</p></li>
<li><p>(Insturction following) Follows additional guidelines if any (specified by the user).</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We can leverage established relevance and ranking quality metrics to evaluating the <strong>retrieval quality</strong>. For example</p>
<ul class="simple">
<li><p>One can use LLM as query-document relevance labeler, and compute precision and nDCG metrics. When we adopt RAG to a new domain, we might not have enough test data to evaluate how the system works. We can leverage LLM to generate synthetic (question, answer) pairs.</p></li>
<li><p><strong>Diversity</strong> of retrieved results might also play an important role in tasks that require LLM to generate <strong>complete and comprehensive results</strong>. As typical ranking metrics does not penalize duplicate results, one might need to develop alternative diversity metrics.</p></li>
</ul>
<p>Evaluting the response quality is not a straight forward task and could be subjective. One cose-effective way is to use a powerful LLM (e.g. GPT-4) or text encoder model to decide the response quality from different aspects. For example,</p>
<ul class="simple">
<li><p><strong>Consistence &amp; Faithfulness</strong>: One can use LLM to validate if claims in the generated output is consistent with the claims in the retrieved context.</p></li>
<li><p><strong>Relevance</strong>: One can use text encoder to measure the semantic similarity between the query and the answer in the embedding space.</p></li>
<li><p><strong>Correctness &amp; usefulness</strong>: If one has the reference answer, one can use string matching approach like BLEU score to check if the generated answer matches that of the reference answer. Checking usefulness will be dependent on user scenarios.</p></li>
</ul>
<p>There are also efforts to automate the RAG evaluation process, as shown in the following [<a class="reference internal" href="#chapter-rag-fig-rag-rag-checker"><span class="std std-numref">Fig. 21.5</span></a>] from <strong>RAGChecker</strong> <span id="id2">[<a class="reference internal" href="#id20" title="Dongyu Ru, Lin Qiu, Xiangkun Hu, Tianhang Zhang, Peng Shi, Shuaichen Chang, Jiayang Cheng, Cunxiang Wang, Shichao Sun, Huanyu Li, and others. Ragchecker: a fine-grained framework for diagnosing retrieval-augmented generation. arXiv preprint arXiv:2408.08067, 2024.">RQH+24</a>]</span>.</p>
<p>The key idea is to separate the overall metrics into retriever metrics and generator metrics and to compute metrics at a fine-grained chunks or claim level.</p>
<p>Ideally, a <strong>perfect retriever</strong> returns precisely all claims needed to generate the ground-truth answer. Therefore,</p>
<ul class="simple">
<li><p>One can use <strong>precision</strong> to measure how many chunks are relevant (i.e., any ground-truth claim is in it) with respect to all retrieved chunks.</p></li>
<li><p>One can use <strong>claim recall</strong> to measure how many claims made in the ground-truth answer are covered by retrieved chunks.</p></li>
</ul>
<p>Given retrieved chunks (possibly mixing relevant and irrelevant information), a <strong>perfect generator</strong> would identify and include all ground-truth-relevant claims and ignore any that are not. Because the generator’s results have dependency on retrieved chunks, we use the following metrics to capture different aspects of its performance.</p>
<ul class="simple">
<li><p><strong>Context utilization</strong>, which captures percentage of correct claims in the final output over the correct claims in the retrieved chunks.</p></li>
<li><p><strong>Noise sensitivity</strong>, which is the percentage of incorrect claims arising from retrieved chunks over the total number of output claims. A generator with high noise tolerance is expected to have lower number of incorrect claims arsing from retrieved chunks.</p></li>
<li><p><strong>Hallucination</strong>, which is the percentage of made-up, incorrect claims over the total number of output claims. The made-up claims here refers to claims not coming from retrieved chunks.</p></li>
<li><p><strong>Self-knowledge</strong>, which is the percentage of correct claims not coming from retrieved chunks over the total number of output claims. This captures the ability to utilize its own knowledge.</p></li>
<li><p><strong>Faithfulness</strong>, which is the percentage of claims coming from retrieved chunks over the total number of output claims. A perfectly failthful generator will have every output claims originated from retrieved chunks; In other words, its hallucination and self-knowledge metrics are zero.</p></li>
</ul>
<figure class="align-default" id="chapter-rag-fig-rag-rag-checker">
<a class="reference internal image-reference" href="../../_images/rag_checker_demo.png"><img alt="../../_images/rag_checker_demo.png" src="../../_images/rag_checker_demo.png" style="width: 566.15px; height: 508.3px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.5 </span><span class="caption-text">llustration of the proposed metrics in RAGChecker. Image from <span id="id3">[<a class="reference internal" href="#id20" title="Dongyu Ru, Lin Qiu, Xiangkun Hu, Tianhang Zhang, Peng Shi, Shuaichen Chang, Jiayang Cheng, Cunxiang Wang, Shichao Sun, Huanyu Li, and others. Ragchecker: a fine-grained framework for diagnosing retrieval-augmented generation. arXiv preprint arXiv:2408.08067, 2024.">RQH+24</a>]</span>.</span><a class="headerlink" href="#chapter-rag-fig-rag-rag-checker" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="rag-optimization-documents">
<h2><span class="section-number">21.4. </span>RAG Optimization: Documents<a class="headerlink" href="#rag-optimization-documents" title="Link to this heading">#</a></h2>
<section id="indexing-data-sources">
<h3><span class="section-number">21.4.1. </span>Indexing Data Sources<a class="headerlink" href="#indexing-data-sources" title="Link to this heading">#</a></h3>
<p>In the indexing stage, there are different data sources, and each has its benefits and challenges.</p>
<div class="pst-scrollable-table-container"><table class="table" id="id1563">
<caption><span class="caption-number">Table 21.1 </span><span class="caption-text">Retrieval Data Sources</span><a class="headerlink" href="#id1563" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head text-left"><p>Data Type</p></th>
<th class="head text-left"><p>Examples</p></th>
<th class="head text-left"><p>Benefits</p></th>
<th class="head text-left"><p>Challenges</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p>Unstructured Data</p></td>
<td class="text-left"><p>Text, Web pages, Wikipedia, domain specific corpus</p></td>
<td class="text-left"><p>Large availability</p></td>
<td class="text-left"><p>Need quality control (e.g., remove bias, noisy content) during indexing time; Difficult to parse</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>Semi-structured Data</p></td>
<td class="text-left"><p>PDFs, structured markdowns, or Data that contains a combination of text, table, image information.</p></td>
<td class="text-left"><p>Cleaner content than unstructured text and web pages</p></td>
<td class="text-left"><p>Challenges are chunking while preserving table completeness. Converting table to text requires additional tools.</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>Structured Data</p></td>
<td class="text-left"><p>Knowledge base, knowledge graph.</p></td>
<td class="text-left"><p>Organized, clean information</p></td>
<td class="text-left"><p>High cost to maintain up-to-date information; Need tools to generate KG search queries; requires additional effort to build, validate, and maintain structured databases.</p></td>
</tr>
</tbody>
</table>
</div>
<p>Performing search in a structured knowledge base usually involving additional preprocessing steps than performing search in unstructred/semi-structred data source
<span id="id4">[<a class="reference internal" href="#id1552" title="Xintao Wang, Qianwen Yang, Yongting Qiu, Jiaqing Liang, Qianyu He, Zhouhong Gu, Yanghua Xiao, and Wei Wang. Knowledgpt: enhancing large language models with retrieval and storage access on knowledge bases. arXiv preprint arXiv:2308.11761, 2023.">WYQ+23</a>]</span>. For example, to search entity in a knowledge base, we need to first extract entities from the query [<a class="reference internal" href="#chapter-rag-fig-rag-knowledge-base-demo"><span class="std std-numref">Fig. 21.6</span></a>].</p>
<figure class="align-default" id="chapter-rag-fig-rag-knowledge-base-demo">
<a class="reference internal image-reference" href="../../_images/RAG_knowledge_base.png"><img alt="../../_images/RAG_knowledge_base.png" src="../../_images/RAG_knowledge_base.png" style="width: 561.0px; height: 285.0px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.6 </span><span class="caption-text">Comparison between retrieval results from document corpus and knowledge bases. Retrieval from knowledge
base (based on key phrases extracted by LLM) could avoid concept/entity missing issue. Image from <span id="id5">[<a class="reference internal" href="#id1552" title="Xintao Wang, Qianwen Yang, Yongting Qiu, Jiaqing Liang, Qianyu He, Zhouhong Gu, Yanghua Xiao, and Wei Wang. Knowledgpt: enhancing large language models with retrieval and storage access on knowledge bases. arXiv preprint arXiv:2308.11761, 2023.">WYQ+23</a>]</span>.</span><a class="headerlink" href="#chapter-rag-fig-rag-knowledge-base-demo" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="document-parsing">
<h3><span class="section-number">21.4.2. </span>Document Parsing<a class="headerlink" href="#document-parsing" title="Link to this heading">#</a></h3>
<p>Depending on the type document sources, we need to use different tools to extract text, image, etc from the document.</p>
<p>For html webpage and markdown files, which use tags or specific syntax to organize texts, there are <a class="reference external" href="https://docs.llamaindex.ai/en/stable/api_reference/node_parsers/">available tools</a> to extract texts from tags like headings, body, etc.</p>
<p>Parsing PDFS is more challenging due to its large variation of layout and organization. For relatively simple PDF, one can use rule-based method to extract layout and structure based on pre-defined patterns. However, rule-based methods are less useful for PDFs with complex layouts.</p>
<p>A more advanced approach will leverage OCR (Optical Character Recognition), which treat each page as an image and extract elements from the image. It also leverage advanced LLMs (e.g., multi-modality LLM) to extract and separate distinct elements like code, image, table. There are many available online services in this line of approach.</p>
</section>
<section id="data-source-augmentation">
<h3><span class="section-number">21.4.3. </span>Data Source Augmentation<a class="headerlink" href="#data-source-augmentation" title="Link to this heading">#</a></h3>
<p>For unstructured data sources, it can improve document understanding and feature derivation by augmenting the data source with additional information.</p>
<p>For example, chunks can be enriched with metadata information such as page number, file name, author, location, category, key entities, timestamp. Augmented data can also be artificially constructed. For example, adding summaries of paragraph, as well as introducing queries can be answered by the paragraphs (known as doc2query <a class="reference internal" href="#chapter-rag-fig-rag-doc2-query"><span class="std std-numref">Fig. 21.7</span></a> <span id="id6">[<a class="reference internal" href="#id1434" title="Rodrigo Nogueira, Wei Yang, Jimmy Lin, and Kyunghyun Cho. Document expansion by query prediction. arXiv preprint arXiv:1904.08375, 2019.">NYLC19</a>]</span>).Metadata are useful matching signal for retrieval stage. For example,</p>
<ul class="simple">
<li><p>Location can be used to improve the retrieval results for location sensitive query.</p></li>
<li><p>Timestamp can be used to improve time-aware retrieval model, ensuring the fresh knowledge are ranked higher and avoiding outdated information.</p></li>
<li><p>Key entities in metadata can help retrieval of documents mentioning particular people, location, etc.</p></li>
</ul>
<p>For multi-modality elements like tables, images, and codes, it is critical to add metatable to make them searchable. For example</p>
<ul class="simple">
<li><p>Add titles and key summary for table</p></li>
<li><p>Add captions for images using text to image encoder-decoder models</p></li>
<li><p>Add code description for code snippet</p></li>
</ul>
<p>A key consideration when enrish documents with the various metadata is the associated compute costs, as nowadays many metadata are extracted using LLMs. One can optimize the cost by using cheaper LLM models or only selecting critical documents for enrishment.</p>
<figure class="align-default" id="chapter-rag-fig-rag-doc2-query">
<a class="reference internal image-reference" href="../../_images/doc_2_query.png"><img alt="../../_images/doc_2_query.png" src="../../_images/doc_2_query.png" style="width: 508.2px; height: 374.4px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.7 </span><span class="caption-text">Use doc2query to enhance retrieval performance. Image from <span id="id7">[<a class="reference internal" href="#id1434" title="Rodrigo Nogueira, Wei Yang, Jimmy Lin, and Kyunghyun Cho. Document expansion by query prediction. arXiv preprint arXiv:1904.08375, 2019.">NYLC19</a>]</span>.</span><a class="headerlink" href="#chapter-rag-fig-rag-doc2-query" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="document-splitting-and-granularity">
<h3><span class="section-number">21.4.4. </span>Document Splitting and Granularity<a class="headerlink" href="#document-splitting-and-granularity" title="Link to this heading">#</a></h3>
<p>During document indexing stage, we need to split documents into different <strong>chunks</strong>. The goal is to break down a full-length documents into smaller, more manageable pieces of text. This serves a few purposes:</p>
<ul class="simple">
<li><p>Creating semantic units of data centered around specific information: This can make it easier to retrieve and use the data, as it is organized into smaller, more focused units.</p></li>
<li><p>Allowing knowledge to fit within the model’s prompt limits: If we feed a full-length document into the prompt, we would be likely to run into size limit problems.</p></li>
<li><p>Allowing the creation of relationships between chunks: This means that chunks can be linked together based on their relationships (the relationship can be as simple as preceding or next chunks), creating a network of interconnected data. This can be useful to derive structures within the documents. See <a class="reference internal" href="#chapter-rag-sec-basic-rag-chunk-relationship"><span class="std std-ref">Document Chunk Relationship</span></a>.</p></li>
</ul>
<figure class="align-default" id="chapter-rag-fig-rag-document-spliting">
<a class="reference internal image-reference" href="../../_images/document_spliting.png"><img alt="../../_images/document_spliting.png" src="../../_images/document_spliting.png" style="width: 654.75px; height: 176.85px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.8 </span><span class="caption-text">Documents are splitted into inter-connected chunks.</span><a class="headerlink" href="#chapter-rag-fig-rag-document-spliting" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The size of chunks ranges from fine to coarse, including phrases, sentence, paragrpahs.  From retrieval perspective, coarse-grained retrieval units fundamentally improve the <strong>recall at the cost of precision</strong>; that is, it can provide more relevant information for the problem, but they may also contain redundant, verbose content, which could distract the retriever and language models in downstream tasks. Intutively, encoding a large chunk of text into a single vector will have information loss, leading to poor retriever performance.</p>
<p>On the other hand, fine-grained retrieval unit increases the burden of retrieval - it increases the number of chunks needed for offline indexing and requires retrieving more chunks for online querying stage. Despite its higher cost, <strong>fine-grained retrieval unit does not guarantee context completeness and semantic integrity</strong> (i.e., not enough context). As a result, the quality of LLM response will be affected negatively.</p>
<p>From a high level, an ideal splitting should consider the following factors:</p>
<ul class="simple">
<li><p><strong>Semantic coherence</strong>: Chunks should maintain semantic coherence - split boundaries should respect natural semantic units and closely related information should stay in the same chunk.</p></li>
<li><p><strong>Size consistency</strong>: Chunks should be sized appropriately for the embedding model.</p></li>
<li><p><strong>Information density</strong>: Each chunk should contain sufficient information to be independently meaningful.</p></li>
</ul>
<p>There are different approaches to splitting:</p>
<ul class="simple">
<li><p><strong>Mechanical splitting</strong> based on a fixed window size. This has the lowest processing cost, but there is no guaratee on maintaining semantic completeness for each chunk - it can create arbitrary breakpoints in the middle of sentences. <strong>One mitigation is to use overlapping sliding windows during splitting.</strong></p></li>
<li><p><strong>Structure-aware splitting</strong> by leveraging document structures (headers, sections). This also has low processing cost and it respect the hierachical organization of the docuemnt. However, <strong>the chunk size can vary a lot as different documents can organize differently</strong>. Also, this method can only apply to relatively formal text data with such structural annotations.</p></li>
<li><p><strong>Semantic-based splitting.</strong> This method invovles using language understanding model to predict the semantic relationship between sentences and paragraphs. For example, we can use BERT to predict if two sentences are sementically close via the next sentence prediction task.  Consecutive sentences and paragraphs that are closely related to each other will be grouped into the same chunk. This method is much costly compared to previously two approaches, but it preserves topic coherence within the chunk.</p></li>
</ul>
</section>
<section id="document-chunk-relationship">
<span id="chapter-rag-sec-basic-rag-chunk-relationship"></span><h3><span class="section-number">21.4.5. </span>Document Chunk Relationship<a class="headerlink" href="#document-chunk-relationship" title="Link to this heading">#</a></h3>
<p>Creating relationships between chunks can be useful for several reasons:</p>
<ul class="simple">
<li><p>Enables more contextual querying: By linking chunks together, you can leverage their relationships during querying to retrieve additional relevant context. For example, when querying a node, you could also return the previous or next chunk to provide more context.</p></li>
<li><p>Allows source tracking: Relationships encode where chunks originated and how they are connected. This is useful when you need to identify the original source of a chunk.</p></li>
<li><p>Enables navigation through nodes: Traversing Nodes by their relationships enables new types of queries. For example, finding the next chunk that contains some keyword. Navigation along relationships provides another dimension for searching.</p></li>
<li><p>Supports the construction of knowledge graphs: Chunks and relationships are the building blocks of knowledge graphs. Linking chunks into a graph structure allows for constructing knowledge graphs from text</p></li>
<li><p>Improves the index structure: Some more complex indexes, such as trees and graphs, utilize chunk relationships to build their internal structure. Relationships allow the construction of more complex and expressive index topologies.</p></li>
</ul>
<p>In summary, relationships augment the chunk with additional contextual connections. This supports more expressive querying, source-tracking knowledge graph construction, and complex index structures.</p>
<p>The most basic relationship between chunks are a previous or next relationship between them. The relationship tracks the order of chunks within the original Document.</p>
<p>There are other types of relationships that we could define.</p>
<ul class="simple">
<li><p>SOURCE: The source relationship represents the original source Document that a chunk was extracted or parsed from.</p></li>
<li><p>PARENT: The parent relationship indicates a hierarchical structure where the chunk with this relationship is one level higher than the associated chunk. In a tree structure, a parent chunk would have one or more children. This relationship is used to navigate or manage nested data structures where you might have a main chunk and subordinate chunks representing sections, paragraphs, or other subdivisions of the main chunk.</p></li>
<li><p>CHILD: This is the opposite of PARENT. Child chunk can be seen as the leaves or branches in a tree structure stemming from their parent chunk.</p></li>
</ul>
<p>In this way, the different levels can be used to adjust the accuracy and depth of search results, allowing users to find information at different granularity levels.</p>
<figure class="align-default" id="chapter-rag-fig-rag-hiercharical-document-spliting">
<a class="reference internal image-reference" href="../../_images/hiercharical_document_spliting.png"><img alt="../../_images/hiercharical_document_spliting.png" src="../../_images/hiercharical_document_spliting.png" style="width: 608.85px; height: 311.85px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.9 </span><span class="caption-text">Documents are organized hierarchical chunks.</span><a class="headerlink" href="#chapter-rag-fig-rag-hiercharical-document-spliting" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="utilizing-knowledge-graph">
<h3><span class="section-number">21.4.6. </span>Utilizing Knowledge Graph<a class="headerlink" href="#utilizing-knowledge-graph" title="Link to this heading">#</a></h3>
<section id="fundamentals">
<h4><span class="section-number">21.4.6.1. </span>Fundamentals<a class="headerlink" href="#fundamentals" title="Link to this heading">#</a></h4>
<p>Compared with unstructed text as an external knowledge source, one can utilize knowledge graphs to represent information in a structured, interconnected format. By querying a knowledge graph, we can usually obtain concise and comprehensive results for the generator to process.</p>
<p>Knowledge graphs consist of entities (nodes) and relationships (edges) between those entities. Entities can represent real-world objects, concepts, or ideas, while relationships describe how those entities are connected.</p>
<p>During querying time, exploring these connections will allow us to find new information and make conclusions that would be hard to draw from separate pieces of information.</p>
<div class="proof example admonition" id="example-1">
<p class="admonition-title"><span class="caption-number">Example 21.2 </span> (Knowledge graph example)</p>
<section class="example-content" id="proof-content">
<p>Suppose we have a collection of documents containing text chunks describing different person works for different companies.</p>
<p>To utilize knowledge graph in the RAG, we first use LLM to extract entities and their relationship from documents. In this case, we can extract the information on <em>person works for company</em>, where <em>person</em> and <em>company</em> are entities, and <em>works for</em> is relationship.</p>
<p>For an easy local query like <em>where does Tom work?</em>, we start with the knowledge graph node <em>Tom</em>, and follow the <em>works for</em> relationship edge to search for answer. Such local query is also straight forward for basic RAG as long as there are sentences in the original text describring Tom’s employment status.</p>
<p>For a global query like <em>who works for company DeepAI</em>, we start with the knolwedge graph node <em>DeepAI</em>, and follow the <em>works for</em> relationship edge to search for all the persons working for DeepAI. If the <em>work for</em> fact is scattered, and <em>implicitly stated</em> in different chunks, it is very challenging for basic RAG retrieve all these relevant chunks (i.e., the recall needs to be sufficiently high).</p>
<p>For another reasoning-needed query <em>does Michael work for the same company as Tom</em>, with knowledge graph, we can easily solve the query by examining nodes of <em>Michael</em> and <em>Tom</em> as well as their edges to draw conclusion.</p>
</section>
</div><p>The following table compares knowledge graph and vector databases from different aspects.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Feature</p></th>
<th class="head text-center"><p>Knowledge Graphs</p></th>
<th class="head text-center"><p>Vector Databases</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>Data Representation</p></td>
<td class="text-center"><p>Entities (nodes) and relationships (edges) between entities, forming a graph structure.</p></td>
<td class="text-center"><p>High-dimensional vectors, each representing a chunk of text from a document.</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>Retrieval Method</p></td>
<td class="text-center"><p>Starting with nodes and traversing the graph following relationship edges</p></td>
<td class="text-center"><p>Similarity search in high dimensional space to identify most relevant chunks</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>Explainability and transparency</p></td>
<td class="text-center"><p>Human-interpretable representation of knowledge, include graph structure and relationships between entities.</p></td>
<td class="text-center"><p>Less interpretable to humans due to high-dimensional numerical representations. Challenging to directly understand relationships or reasoning behind retrieved information.</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>Inference Time Reasoning</p></td>
<td class="text-center"><p>Can reason over relationship among entities. Both explicit and implicit Relationship can be extracted during knowledge construction time. New knowledge can be derived from inference time</p></td>
<td class="text-center"><p>Limited. Vector similarity may miss implicit relationships during inference time. Can identify explicit and simple relationship but not complex relationships.</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>Scalability</p></td>
<td class="text-center"><p>More cost to construct knowledge graph for new documents, which involves incoporating new entities and relationships from documents</p></td>
<td class="text-center"><p>Minimal cost to indexing new documents</p></td>
</tr>
</tbody>
</table>
</div>
<p>Both knowledge graphs and vector databases have their strengths and use cases, and the choice between them depends on the specific requirements of the application. Knowledge graphs excel at representing and reasoning over small-scaled structured knowledge (e.g., representing complex relationships and enabling multi-hop reasoning), while vector databases are well-suited for large scale tasks that rely heavily on semantic similarity and simple reasoning.</p>
</section>
<section id="challenges">
<h4><span class="section-number">21.4.6.2. </span>Challenges<a class="headerlink" href="#challenges" title="Link to this heading">#</a></h4>
<p>Setting up knowledge graphs for RAG applications in the real world can be a complex task with several challenges:</p>
<p><strong>Knowledge graph construction</strong>: Building a high-quality knowledge graph is a complex and time-consuming process that requires significant domain expertise and effort. Extracting entities, relationships, and facts from various data sources and integrating them into a coherent knowledge graph can be challenging, especially for large and diverse datasets. It involves understanding the domain, identifying relevant information, and structuring it in a way that accurately captures the relationships and semantics.</p>
<p><strong>Data integration</strong>: RAG applications often need to integrate data from multiple heterogeneous sources, each with its own structure, format, and semantics. Ensuring data consistency, resolving entity and relationship conflicts, and mapping entities and relationships across different data sources is non-trivial. It requires careful data cleaning, transformation, and mapping to ensure that the knowledge graph accurately represents the information from various sources.</p>
<p><strong>Knowledge graph maintenance and update</strong>: To ensure up-to-date RAG application, Knowledge graphs also need to be continuously updated and maintained as new knowledge becomes available or existing knowledge changes. Keeping the knowledge graph up-to-date and consistent involves monitoring changes in the data sources, identifying relevant updates, and propagating those updates to the knowledge graph while maintaining its integrity and consistency.</p>
<p><strong>Scalability and performance</strong>: As the knowledge graph grows in size and complexity, ensuring efficient storage, retrieval, and querying of the graph data becomes increasingly challenging. Scalability and performance issues can arise, particularly for large-scale RAG applications with high query volumes.</p>
</section>
</section>
</section>
<section id="rag-optimization-query-understanding-and-rewriting">
<h2><span class="section-number">21.5. </span>RAG Optimization: Query Understanding and Rewriting<a class="headerlink" href="#rag-optimization-query-understanding-and-rewriting" title="Link to this heading">#</a></h2>
<section id="id8">
<h3><span class="section-number">21.5.1. </span>Motivation<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p>Query understanding and rewriting is a crucial component in optimizing RAG  systems. The effectiveness of RAG heavily depends on the quality of the retrieval step, which in turn relies on how well the system understands and processes user queries. Raw user queries that ** don’t directly match the way information is indexed offline** can lead to poor retrieval results.</p>
<p>Specifically, Key challenges that necessitate query rewriting include:</p>
<ul class="simple">
<li><p><strong>Vocabulary mismatch</strong> between user queries and stored documents, particularly for <strong>domain-specific queries</strong> containing terminology and jargon</p></li>
<li><p><strong>Implicit context</strong> that needs to be made explicit</p></li>
<li><p><strong>Complex queries</strong> that combine multiple concepts</p></li>
<li><p><strong>Contextual understanding</strong> from multi-turn conversations</p></li>
</ul>
<div class="pst-scrollable-table-container"><table class="table" id="id1564">
<caption><span class="caption-number">Table 21.2 </span><span class="caption-text">Retrieval Data Sources</span><a class="headerlink" href="#id1564" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head text-left"><p>Query Type</p></th>
<th class="head text-left"><p>Example</p></th>
<th class="head text-left"><p>Rewrite Angle/Result</p></th>
<th class="head text-left"><p>Explanation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p>Vocabulary mismatch</p></td>
<td class="text-left"><p>Why is my car not starting</p></td>
<td class="text-left"><p>Car ignition failure diagnosis</p></td>
<td class="text-left"><p>Document side is likely to contain words like ignition.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>Vocabulary mismatch</p></td>
<td class="text-left"><p>Can my boss fire me for being sick</p></td>
<td class="text-left"><p>Employment termination regulations regarding medical leave</p></td>
<td class="text-left"><p>Document side is likely to contain termination, medical leave.</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>Implicit context</p></td>
<td class="text-left"><p>Current state tax rates</p></td>
<td class="text-left"><p>State tax rate for CA residents in 2024</p></td>
<td class="text-left"><p>Incoporate time and location information into the query to improve precision.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>Complex queries</p></td>
<td class="text-left"><p>Can I take ibuprofen with my blood pressure medication while pregnant?</p></td>
<td class="text-left"><p>Decompose to three different subqueries on ibuprofen, blood pressure medication, and pregancy.</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>Multi-turn conversational query</p></td>
<td class="text-left"><p>Turn 1: “Tell me about Tesla Model 3”; Turn 2: “What about its safety features?”</p></td>
<td class="text-left"><p>Safety features of Tesla Model 3</p></td>
<td class="text-left"><p>Incoporate previous context into the rewritten query</p></td>
</tr>
</tbody>
</table>
</div>
<!-- 

Motivation, why we need query understanding and rewrite


Understand what scenario we need to rewrite
* Highly specialized domains like law, medical
* Complex, multi-concept queries: convert to multiple subquestions, convert to multiple subqueries
* Multi-turn conversions: rewrite query based on historical conversation and context

How to rewrite?
* Use classical model to perform synoym expansion, acroynyn expansion, etc. 
* Use generative model to perform query write
* Use RAG + LLM to perform query understanding and rewrite
 -->
<!-- 

Highly Specialized Domains

In domains like law and medicine, effective query rewriting is essential because:
- Technical terminology may have multiple variations or synonyms
- Professional jargon needs to be mapped to standardized terms
- Concepts may be expressed differently in formal vs. informal language
- Domain-specific acronyms need expansion

````{prf:example}
- Original query: "What's the standard treatment for BP?"
- Rewritten: "What is the standard treatment for high blood pressure OR hypertension"
```` -->
</section>
<section id="approach-to-vocalbulary-mismatch">
<h3><span class="section-number">21.5.2. </span>Approach to Vocalbulary Mismatch<a class="headerlink" href="#approach-to-vocalbulary-mismatch" title="Link to this heading">#</a></h3>
<p>Vocalbulary mismatch often occur in querstion-answering in high-specialized domains, like law, science, engineering, etc.
The reason is that concepts are often expressed differently in document language (more formal) vs. query language (less formal). Query understanding and rewriting is essential to bridge such gap by rewriting user’s query concept to professional jargon.</p>
<p>Traditional techniques focus on lexical and syntactic rule-based transformations, including</p>
<ul class="simple">
<li><p>Spelling correction and normalization</p></li>
<li><p>Stop word removal and stemming</p></li>
<li><p>Query expansion using WordNet or domain-specific dictionary or co-occurrence statistics</p></li>
<li><p>Acronym restoring using predefined mappings</p></li>
</ul>
<p>Tradictional approaches are usually computationally efficient, and it is predictable and interpretable. However, it often requires significant manual effort to craft rules and update dictionary.</p>
<p>With the advancement of LLM, LLM can be used for more sophisticated query rewriting, as shown in the following example.</p>
<div class="proof example admonition" id="example-2">
<p class="admonition-title"><span class="caption-number">Example 21.3 </span> (LLM prompt to query rewrite)</p>
<section class="example-content" id="proof-content">
<p><strong>Prompt:</strong>
Given a query <em>What’s the state tax rate?</em> from a user located at <em>San Jose, US</em> on <em>June, 2024</em>.
Rewrite this query to help retrieve comprehensive results from search engine like Google.</p>
</section>
</div><p>This approach leverages the excellent language understanding and generation of LLM, and it can capture implicit context and semantic variations without explicit rules. However, it also has the following drawbacks.</p>
<ul class="simple">
<li><p>High computational cost. LLM inference is much costly than traditional technique. One can reduce the cost by using effectively distilled SLM and by using the triggering model to decide when to invoke LLM.</p></li>
<li><p>Lack of knowledge for queries involving rare entity names. This is an inherent drawback of LLM, which can be addressed by using a query-rewrite oriented RAG system.</p></li>
</ul>
</section>
<section id="approach-to-complex-multi-concept-queries">
<h3><span class="section-number">21.5.3. </span>Approach to Complex Multi-Concept Queries<a class="headerlink" href="#approach-to-complex-multi-concept-queries" title="Link to this heading">#</a></h3>
<p>Many user queries combine multiple concepts or requirements that need to be decomposed for effective retrieval. The query decomposition involves the following steps:</p>
<ul class="simple">
<li><p>Breaking down complex queries into simpler, atomic questions</p></li>
<li><p>Creating multiple focused, logically-related subqueries</p></li>
</ul>
<div class="proof example admonition" id="example-3">
<p class="admonition-title"><span class="caption-number">Example 21.4 </span></p>
<section class="example-content" id="proof-content">
<p>The original query <em>Can I take ibuprofen with my blood pressure medication while pregnant?</em>” can be decomposed into:</p>
<ol class="arabic simple">
<li><p>Is ibuprofen safe during pregnancy?</p></li>
<li><p>What are the interactions between ibuprofen and blood pressure medication”</p></li>
</ol>
</section>
</div><p>LLM is best probably the best tool to handle complex queries. To guide LLM to produce useful and desired outcome, we can apply various prompting technique, like few shot prompting and CoT [<a class="reference internal" href="../chapter_prompt/basic_prompt.html#chapter-prompt-sec-cot-prompting"><span class="std std-ref">Chain-of-Thought (CoT) Prompting</span></a>]. For queries involving complex reaonsing, we can use <a class="reference internal" href="../chapter_prompt/advanced_prompt.html#chapter-prompt-sec-step-back-prompting"><span class="std std-ref">Step Back Prompting</span></a>.</p>
</section>
<section id="approach-to-multi-turn-conversations">
<h3><span class="section-number">21.5.4. </span>Approach to Multi-Turn Conversations<a class="headerlink" href="#approach-to-multi-turn-conversations" title="Link to this heading">#</a></h3>
<p>In conversational QA scenario (e.g., a chatbot), understanding user’s query requires the understanding of previous conversational turns. In complex scenarioes, it needs the properly handling of</p>
<ul class="simple">
<li><p>Resolving pronouns and references (user might use this, that, he, she to refer to entities in previous turns)</p></li>
<li><p>Potential conflicting aspect (user might need agree and then disagree as the conversation evolves)</p></li>
<li><p>Topic switches (user might switch to another topic during one conversation session)</p></li>
</ul>
<p>Given the complexity of multi-turn conversations, using LLM can offer a clean solution rather than using multiple specialized NLP modules/models.</p>
</section>
<section id="advanced-query-categorization">
<h3><span class="section-number">21.5.5. </span>Advanced Query Categorization<a class="headerlink" href="#advanced-query-categorization" title="Link to this heading">#</a></h3>
<p>To better understand the RAG performance over different query types, one can further categorize queries into the following types:</p>
<p><strong>Explicit fact queries</strong>: Explicit fact queries are the most basic and straightforward type, which directly request specific, known facts, with answers readily available in the provided data, requiring no additional reasoning processes. For instance, the query <em>Who invented the telephone?</em>, its answer, <em>Alexander Graham Bell invented the telephone</em> is directly retrieved from external data.</p>
<p><strong>Implicit fact queries</strong>:  Implicit fact queries are more complex than explicit ones, requiring the model to reveal hidden facts within the data. The required information might be scattered across multiple data fragments or need to be obtained through simple reasoning processes. For example, the question, <em>Which country won the most gold medals in the 2020 Olympics?</em> requires retrieving data on multiple countries’ gold medals and comparing them.</p>
<p><strong>Interpretable rationale queries</strong>: Interpretable rationale queries further enhance the complexity of the RAG architecture, requiring not only the mastery of facts but also the ability to understand and apply domain-specific reasoning justifications closely related to the data context. These queries demand both factual knowledge and the ability to interpret domain-specific rules, often sourced from external resources and rarely encountered in the initial pre-training of general language models.</p>
<p>For instance, in financial auditing, language models need to follow regulatory compliance guidelines to assess whether a company’s financial statements meet standards; in technical support scenarios, they must adhere to predefined troubleshooting workflows to effectively respond to user queries. These applications require the RAG architecture to provide precise and compliant responses while generating clear, understandable reasoning process explanations.</p>
<p><strong>Hidden Rationale Queries</strong>: Hidden rationale queries represent the highest level and most challenging category within the RAG task classification. These queries require AI models to infer complex, unrecorded reasoning justifications relying on patterns and outcome analysis within the data. For example, in IT operations, language models need to mine implicit knowledge from historical events resolved by cloud operations teams, identifying successful strategies and decision-making processes; in software development, they must extract guiding principles from past debugging error records.</p>
<!-- In handling explicit fact queries, the key to the RAG architecture lies in efficient retrieval and accurate matching. Microsoft leverages models like BERT to encode queries and documents into dense vectors for similarity matching, enabling rapid location and extraction of required information from vast datasets. Additionally, classic retrieval algorithms like BM25 play a crucial role, ranking relevance based on term frequency and document frequency to ensure the retrieved information highly matches the user's query.

The application scenarios of explicit fact queries are extensive, including knowledge-based question answering and information retrieval. At this level, the RAG architecture primarily relies on vector space and semantic similarity calculations to achieve fast and accurate answer extraction.

In implicit fact queries, the RAG architecture introduces reasoning and action elements, necessitating a more agentic approach. Microsoft employs multi-hop reasoning and information aggregation techniques at this level, constructing relationship graphs among documents for multi-round retrieval and gradually collecting required information. Additionally, graph neural networks and iterative retrieval methods are used to effectively combine information from different sources, generating comprehensive and accurate answers.

The application scenarios of implicit fact queries are equally broad, including but not limited to data analysis and decision support. At this level, the RAG architecture not only requires retrieval capabilities but also a certain degree of reasoning to reveal hidden patterns and regularities in the data.

Interpretable Rationale Queries: The Combination of Domain Knowledge and Logical Reasoning

Interpretable rationale queries further enhance the complexity of the RAG architecture, requiring not only the mastery of facts but also the ability to understand and apply domain-specific reasoning justifications closely related to the data context. These queries demand both factual knowledge and the ability to interpret domain-specific rules, often sourced from external resources and rarely encountered in the initial pre-training of general language models.

For instance, in financial auditing, language models need to follow regulatory compliance guidelines to assess whether a company's financial statements meet standards; in technical support scenarios, they must adhere to predefined troubleshooting workflows to effectively respond to user queries. These applications require the RAG architecture to provide precise and compliant responses while generating clear, understandable reasoning process explanations.

To achieve this, Microsoft integrates neural-symbolic methods in the RAG architecture, combining neural networks with symbolic reasoning systems, and uses Chain-of-Thought prompting techniques to guide language models through step-by-step reasoning. These technologies enable the RAG architecture to excel in specific domains while providing interpretable reasoning processes, enhancing user trust in the answers.

### 4. Hidden Rationale Queries: Uncovering Deep-Level Patterns and Meanings

Hidden rationale queries represent the highest level and most challenging category within the RAG task classification. These queries require AI models to infer complex, unrecorded reasoning justifications relying on patterns and outcome analysis within the data. For example, in IT operations, language models need to mine implicit knowledge from historical events resolved by cloud operations teams, identifying successful strategies and decision-making processes; in software development, they must extract guiding principles from past debugging error records.

In handling hidden rationale queries, the RAG architecture relies on robust global retrieval capabilities and deep-level understanding. Microsoft introduces knowledge graphs and community detection mechanisms to achieve deep mining and comprehensive grasp of information structures. GraphRAG, as an innovative achievement in this field, leverages large language models to extract entities, relationships, and attributes from source documents, constructing structured knowledge graphs. Community detection algorithms identify closely related entity groups (communities) and generate summaries for each community, enabling comprehensive and accurate answers to complex, multi-topic questions.

The application scenarios of hidden rationale queries include but are not limited to strategic decision-making and market analysis. At this level, the RAG architecture not only provides answers but also reveals the deep-level patterns and meanings behind them, offering strong support for decision-making. -->
</section>
</section>
<section id="rag-optimization-retriever-and-reranker">
<h2><span class="section-number">21.6. </span>RAG Optimization: Retriever and ReRanker<a class="headerlink" href="#rag-optimization-retriever-and-reranker" title="Link to this heading">#</a></h2>
<section id="retrieval-model-enhancement">
<h3><span class="section-number">21.6.1. </span>Retrieval Model Enhancement<a class="headerlink" href="#retrieval-model-enhancement" title="Link to this heading">#</a></h3>
<p>In the basic RAG system, only a dense retrieval model based on vector embedding is used. In general, dense embeddings has good performance on recall as fundamentally it is an inexact, semantically based approach. On the other hand, sparse retrieval (e.g., inverted index plus BM25), which relies on exact tem matching, has good performance on precision, particularly for queries with low level details (e.g., specific number, year, name) and rare entities. In practice, it is beneficial to combine sparse and dense retrievers and form a <strong>hybrid retriever</strong>.</p>
<p>Specifically, there are several drawbacks associated with dense retriever:</p>
<ul class="simple">
<li><p>Computational cost: Embedding and indexing large volumes of data can be computationally expensive and time-consuming.</p></li>
<li><p>More focus on recall: Dense retrieval systems can sometimes favor recall over precision.</p></li>
<li><p>Difficulty in encoding long documents: Dense models that encode very long content into a  fixed-length vectors can run into information loss issue, where important information can be diluted or lost in the embedding process.</p></li>
<li><p>Logical reasoning gaps: While dense model are excellent at capturing semantic similarity, they typically lack logical reasoning capabilities. This means that they can identify documents that are semantically similar to the query but may struggle to understand context or logical relationships that require reasoning beyond this pattern matching. As a result, they may retrieve documents that are superficially related to the query but not truly relevant to the user’s intent, especially in cases where the query requires an understanding of complex relationships or nuanced reasoning.</p></li>
</ul>
<div class="proof example admonition" id="example-4">
<p class="admonition-title"><span class="caption-number">Example 21.5 </span> (Challenging reasoning queries for dense retriever)</p>
<section class="example-content" id="proof-content">
<ul class="simple">
<li><p><em>Which programming languages are easier to learn than Python but more powerful for data analysis?</em>
Dense retrieval might find documents about programming language learning curves and data analysis capabilities, but struggle with the comparative reasoning needed to identify languages meeting both criteria.</p></li>
<li><p><em>Movies inspired by 1984 but with happy endings</em> Dense retrievers would likely match the semantic similarity to “Movies inspired by 1984” well, but has difficulty to retrieve documents also meeting the <em>happy ending</em> condition. One reason is <em>happy ending</em> is rarely associated with concepts like <em>1984</em>, the model is hard to identify documents with rare co-occurring concepts using simple semantic matching.</p></li>
</ul>
</section>
</div><p>On the other hand, sparse retrieval, despite its inherent vocalbulary mismatch issue,  have several advantages compared to dense retrieval:</p>
<ul class="simple">
<li><p>Efficient handling of large datasets: Sparse retrieval methods, such as BM25, requiring no model and are generally much efficient at handling large datasets.</p></li>
<li><p>High precision: Sparse methods often provide high accuracy in scenarios where the exact matching of terms is critical. They excel at retrieving documents that contain specific keywords present in the user’s query, which is beneficial in applications where keyword specificity is essential.</p></li>
<li><p>Simplicity and interpretability: Sparse retrieval methods are conceptually simpler and more interpretable than dense methods. The fact that they rely on explicit keyword frequencies makes it easier to understand why certain documents are retrieved in response to a query.</p></li>
</ul>
<div class="proof example admonition" id="example-5">
<p class="admonition-title"><span class="caption-number">Example 21.6 </span> (sparse retrieval vs dense retrieval for legal documents)</p>
<section class="example-content" id="proof-content">
<p>Suppose we’ve built a system for retrieving legal documents. In this scenario, user queries would likely include precise legal terms, citations, or specific phrases found in legal texts. Let’s assume a user inputs a query such as, <em>Article 45 of the GDPR regarding personal data transfers on the basis of an adequacy decision</em>. This query contains specific phrases, such as <em>Article 45</em> and <em>GDPR</em>, which are likely to be found in relevant legal documents exactly in this form.</p>
<p>Sparse search is likely to provide very accurate results for such a query. It will accurately locate documents that contain the specific article from the GDPR, reducing noise and irrelevant retrievals. Given that legal documents often have a structured format, with different sections and articles, sparse retrieval methods can efficiently parse through this structured data and retrieve nodes based on direct references found in the query.</p>
<p>Because dense retrieval methods tend to prioritize general meaning over exact term matching, they may produce less accurate results in such a specialized, keyword-specific query.</p>
<p>Unless trained specifically on legal texts, an embedding model used for dense retrieval might struggle to accurately interpret and match the complex legal jargon and specific citation styles used in legal queries.</p>
</section>
</div><p>Combining both sparse and dense approaches can capture different relevance features and can benefit from each other by leveraging complementary relevance information. For instance, both retrieval approaches can be used to generate initial recalled results and send to the next stage for re-ranking.</p>
<p>There are other ways deep model can be used to enhance sparse model. For example,</p>
<ul class="simple">
<li><p><strong>Term weight prediction</strong>: Deep model can be used to predict contextualized term weights in a query, which can help sparse retrieval model to pay more attention to important terms give the query as a context. (See <a class="reference internal" href="../chapter_application_IR/information_retrieval_fundamentals.html#ch-neural-network-and-deep-learning-applicationnlp-irsearch-contextualized-term-importance"><span class="std std-ref">Contextualized Term Importance</span></a>)</p></li>
<li><p><strong>Enhance sparse retrieval ranker</strong>: Sparse retrieval in practice often use much more sophositcated rankers than BM25. These ranker can benefit from query-document semantic similarity feature besides query document exact matching features.</p></li>
</ul>
<p>We are usually face the training data scarcity issue when we adapt a generic retrieval models to a highly specialized domain (e.g., medical, law, scientific). <span id="id9">[<a class="reference internal" href="#id15" title="Zhuyun Dai, Vincent Y Zhao, Ji Ma, Yi Luan, Jianmo Ni, Jing Lu, Anton Bakalov, Kelvin Guu, Keith B Hall, and Ming-Wei Chang. Promptagator: few-shot dense retrieval from 8 examples. arXiv preprint arXiv:2209.11755, 2022.">DZM+22</a>]</span> introduces a LLM-based approach, PROMPTAGATOR,  to enhance task-specific retrievers.</p>
<p>As shown in the <a class="reference internal" href="#chapter-rag-fig-promptagator-demo"><span class="std std-numref">Fig. 21.10</span></a>, PROMPTAGATOR consists of three components:</p>
<ul class="simple">
<li><p>Prompt-based query generation, a task-specific prompt will be combined with a large language model to produce queries for all documents.</p></li>
<li><p>Consistency filtering, which cleans the generated data based on round-trip consistency - query should be answered by the passage from which the query was generated.</p></li>
<li><p>Retriever training, in which a retriever will be trained using the filtered synthetic data.</p></li>
</ul>
<figure class="align-default" id="chapter-rag-fig-promptagator-demo">
<a class="reference internal image-reference" href="../../_images/promptagator_training.png"><img alt="../../_images/promptagator_training.png" src="../../_images/promptagator_training.png" style="width: 765.8px; height: 225.39999999999998px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.10 </span><span class="caption-text">Illustration of PROMPTAGATOR, which generates synthetic data using LLM. Synthetic data, after consistency filtering, is used to train a retriever in labeled data scarcity domain. Image from <span id="id10">[<a class="reference internal" href="#id15" title="Zhuyun Dai, Vincent Y Zhao, Ji Ma, Yi Luan, Jianmo Ni, Jing Lu, Anton Bakalov, Kelvin Guu, Keith B Hall, and Ming-Wei Chang. Promptagator: few-shot dense retrieval from 8 examples. arXiv preprint arXiv:2209.11755, 2022.">DZM+22</a>]</span>.</span><a class="headerlink" href="#chapter-rag-fig-promptagator-demo" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="retrieval-result-quality-control">
<h3><span class="section-number">21.6.2. </span>Retrieval Result Quality Control<a class="headerlink" href="#retrieval-result-quality-control" title="Link to this heading">#</a></h3>
<p>For RAG, maintaining high-quality retrieved data is crucial for generating accurate and coherent responses. Low quality content like redundancy and irrelvant will mislead LLM. In the following, we discuss several different approaches for quality control.</p>
<p><strong>Reranking</strong>: Reranking is a commonly used, and effective quality control measure to improve the precision of retrieved results. Reranking can employ both rule-based methods (utilizing metrics like Diversity, Relevance, and MRR) and model-based approaches (e.g., BERT cross-encoder). The outcome of reranking is to select the most relevant and useful paragraphs for the LLM to consume.</p>
<p><strong>Context Compression</strong>: A common misconception in the RAG process is the belief that retrieving as many relevant documents as possible and concatenating them to form a lengthy retrieval prompt is beneficial. However, excessive context can introduce more noise, diminishing the LLM’s perception of key information .</p>
<p><strong>LLM-based quality evaluator</strong>: We can also prompt the LLM to evaluate the retrieved content before generating the final answer. This allows the LLM to filter out documents with poor relevance.</p>
</section>
</section>
<section id="rag-optimization-llm-understanding-generation">
<h2><span class="section-number">21.7. </span>RAG Optimization: LLM Understanding &amp; Generation<a class="headerlink" href="#rag-optimization-llm-understanding-generation" title="Link to this heading">#</a></h2>
<section id="motivation-and-objective">
<h3><span class="section-number">21.7.1. </span>Motivation and Objective<a class="headerlink" href="#motivation-and-objective" title="Link to this heading">#</a></h3>
<p>With retrieved context, LLM needs to utilize the context and generate desired responses to the user query. A performing RAG system requires the LLM to have the following abilities:</p>
<ul class="simple">
<li><p>Generate faithful and reliable responses that are strictly grounded in the provided context</p></li>
<li><p>Produce robust responses when provided context has noises (e.g., some irrelevant paragraphs)</p></li>
<li><p>Recognize and explicitly reject queries when context is insufficient</p></li>
<li><p>Identify and appropriately handle harmful or inappropriate requests</p></li>
<li><p>Maintain consistent response quality across diverse query types</p></li>
</ul>
<p>The simplest approach to tailor LLM to above needs is through prompting with desired guideline. However, often times prompting off-the-shelf LLM usually does not fully address these fundamental needs; therefore we need additional model finetuning steps to improve the LLM to better understand and utilize retrieved information, which is discussed in the following.</p>
</section>
<section id="prompting">
<h3><span class="section-number">21.7.2. </span>Prompting<a class="headerlink" href="#prompting" title="Link to this heading">#</a></h3>
<p>If we have a capable instructed LLM, prompting is a cost-effective technique to instruct LLM to behave in certain way.</p>
<p>Following is an example prompt that ask LLM to provide tracable answers and to reject the question if it cannot be answered.</p>
<div class="proof example admonition" id="example-6">
<p class="admonition-title"><span class="caption-number">Example 21.7 </span></p>
<section class="example-content" id="proof-content">
<p>You are an AI assistant that helps users learn from the information found in the source material.
Answer the query using only the sources provided below.
Use bullets if the answer has multiple points.
Answer ONLY with the facts listed in the list of sources below. Cite your source when you answer the question
If there isn’t enough information below, say you don’t know.
Do not generate answers that don’t use the sources below.
Query: {query}
Sources_1:{source_1}
Sources_2:{source_2}
Sources_3:{source_3}</p>
</section>
</div></section>
<section id="model-finetuning">
<h3><span class="section-number">21.7.3. </span>Model Finetuning<a class="headerlink" href="#model-finetuning" title="Link to this heading">#</a></h3>
<p>Model finetuning consists of two key steps (summarized in the ):</p>
<ul class="simple">
<li><p>Training data preparation, which is a crucial step to shape the model behavior by specifying desired output and undesired output via (prompt, completion) paired data.</p></li>
<li><p>Training method, which invovles using SFT, DPO, PEFT, etc. See <a class="reference internal" href="../chapter_training/finetuning.html#chapter-training-sec-llm-finetuning"><span class="std std-ref">LLM Finetuning</span></a> and <a class="reference internal" href="../chapter_training/alignment.html#chapter-training-sec-llm-alignment"><span class="std std-ref">LLM Alignement and Preference Learning</span></a>.</p></li>
</ul>
<p>The data preparation consists of the four key steps [<a class="reference internal" href="#chapter-rag-fig-rag-llm-ft-data-source"><span class="std std-numref">Fig. 21.11</span></a>]:</p>
<ul class="simple">
<li><p>Data collection, in which we collect public dataset, priviate data, and use synthetic approach to generate question-context-answer.</p></li>
<li><p>Data selection, in which we include</p>
<ul>
<li><p>Rejection samples where the LLM should learn to identify and reject queries given the context</p></li>
<li><p>Domain-diverse examples to ensure broad applicability</p></li>
<li><p>Domain-example aligning with downstream applications</p></li>
</ul>
</li>
<li><p>Data construction and enrichment, in which</p>
<ul>
<li><p>Responses with hallucination are filtered out</p></li>
<li><p>Source citation patterns are added</p></li>
<li><p>Output style and formats are adjusted to maintain consistence.</p></li>
</ul>
</li>
<li><p>Data selection and refinement - additional data filtering and refinement steps, including balanced mixing of training data of different characteristics, quality control via LLM and heuristic rules.</p></li>
</ul>
<figure class="align-default" id="chapter-rag-fig-rag-llm-ft-data-source">
<a class="reference internal image-reference" href="../../_images/LLM_FT_data_source.png"><img alt="../../_images/LLM_FT_data_source.png" src="../../_images/LLM_FT_data_source.png" style="width: 664.1999999999999px; height: 291.59999999999997px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.11 </span><span class="caption-text">Illustration of four key steps in preparing generator fine-tuning data sources.</span><a class="headerlink" href="#chapter-rag-fig-rag-llm-ft-data-source" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Training data prepared this way ensures that the resulting model will learn to not only generates high-quality responses but also knows when and how to reject queries appropriately.</p>
</section>
<section id="raft-retrieval-augmented-fine-tuning">
<h3><span class="section-number">21.7.4. </span>RAFT: Retrieval Augmented Fine Tuning<a class="headerlink" href="#raft-retrieval-augmented-fine-tuning" title="Link to this heading">#</a></h3>
<p>RAFT <span id="id11">[<a class="reference internal" href="#id1562" title="Tianjun Zhang, Shishir G Patil, Naman Jain, Sheng Shen, Matei Zaharia, Ion Stoica, and Joseph E Gonzalez. Raft: adapting language model to domain specific rag. arXiv preprint arXiv:2403.10131, 2024.">ZPJ+24</a>]</span> is a fine-tuning approach aiming to enhance the LLM’s robustness to irrelevant information during a basic RAG process.</p>
<p>In a basic RAG process, the quality of retrieved document plays a key role in determining the output relevance and correctness of the LLM generator: Incomplete, irrelvance, or incorrect retrieved documents can lead to hallucination or non-factual statements.</p>
<p>RAFT addresses this issue by incoporating the imperfect retrieved sources in the generator fine-tuning process, with the objective of <strong>training the LLM to generate correct responses based on the relevant document while minimizing the negative impact from irrelevant (or distractor) document.</strong></p>
<p>In RAFT <a class="reference internal" href="#chapter-rag-fig-rag-llm-ft-raft"><span class="std std-numref">Fig. 21.12</span></a>, we prepare the training data such that each data point contains a question (Q), a set of documents <span class="math notranslate nohighlight">\(\left(D_k\right)\)</span>, and a corresponding Chain-of-thought (CoT) style answer <span class="math notranslate nohighlight">\(\left(A^*\right)\)</span> generated from one of the document <span class="math notranslate nohighlight">\(D^*\)</span>. We differentiate between two types of documents: <strong>golden</strong> documents <span class="math notranslate nohighlight">\((D^*)\)</span> i.e. the documents from which the answer to the question can be deduced, and <strong>distractor</strong> documents <span class="math notranslate nohighlight">\(\left(D_i\right)\)</span> that do not contain answer relevant information.</p>
<figure class="align-default" id="chapter-rag-fig-rag-llm-ft-raft">
<a class="reference internal image-reference" href="../../_images/RAFT_demo.png"><img alt="../../_images/RAFT_demo.png" src="../../_images/RAFT_demo.png" style="width: 987.6999999999999px; height: 380.79999999999995px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.12 </span><span class="caption-text">Overview of our RAFT method. The top-left figure depicts the RAFT training approach of
adapting LLMs to generate solution from a set of positive and distractor documents. Compared to training with only gold documents, RAFT will enhance model’s robustness to negative documents. At test time, all methods follow the standard RAG setting, provided with a top-k retrieved documents in the context. Image from <span id="id12">[<a class="reference internal" href="#id1562" title="Tianjun Zhang, Shishir G Patil, Naman Jain, Sheng Shen, Matei Zaharia, Ion Stoica, and Joseph E Gonzalez. Raft: adapting language model to domain specific rag. arXiv preprint arXiv:2403.10131, 2024.">ZPJ+24</a>]</span>.</span><a class="headerlink" href="#chapter-rag-fig-rag-llm-ft-raft" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>RAFT fine-tune the language model using standard supervised training based on the following mixture settings.</p>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\(P\)</span> fraction of the questions in the dataset, we retain the golden document along with distractor documents.</p></li>
<li><p>For <span class="math notranslate nohighlight">\((1 − P)\)</span> fraction of the questions in the dataset, we include no golden document and only include distractor documents. The motivation is when there are only distractor documents, we are compelling the model to generate answers using its own knowledge instead of deriving them fromthe context.</p></li>
</ul>
<p>Note that CoT technique is used to create a full reasoning chain, with clear cited sources. CoT technique is shown to improve model performance in RAFT.</p>
<p>In the test time, the model is provided with the Q and top-k documents retrieved by the RAG pipeline. Note that RAFT is independent of the retriever used.</p>
<!-- ### Self-Aware LLM
However, we find that the retrieved knowledge does not always help and even has a
negative impact on original responses occasionally.

To better make use of both internal knowledge and external world knowledge,
we investigate eliciting the model’s ability to
recognize what they know and do not know
(which is also called “self-knowledge”) and
propose Self-Knowledge guided Retrieval augmentation (SKR), a simple yet effective method
which can let LLMs refer to the questions
they have previously encountered and adaptively call for external resources when dealing with new questions.

investigate eliciting the selfknowledge of LLMs and propose a simple yet effective Self-Knowledge guided Retrieval augmentation (SKR) method to flexibly call the retriever
for making better use of both internal and external
knowledge


The proposed direct prompting and in-context
learning methods can elicit self-knowledge of
LLMs to some extent. However, they have several limitations. First, both methods require designing prompts and calling the LLMs for each new
question, which makes it impractical. Second, incontext learning could also be unstable due to contextual bias and sensitivity

| Template |
| :--- |
| Do you need additional information to answer this question? |
| Would you like any extra prompts to help you? |
| Would you like any additional clues? |
| Can you answer this question based on what you  know? |
| Can you solve this question now? |

llm_book_jupyterbook\llm_book\docs\img\chapter_rag\generator_model
```{figure} ../img/chapter_rag/generator_model/LLM_FT_data_source.png
---
scale: 60%
name: chapter_rag_fig_rag_demo
---
omparison between two responses given by InstructGPT. The retrieved passages are relevant but not particularly helpful for solving the question, which influences the model’s judgment and leads to incorrect answers. Image from {cite:p}`wang2023self`.
``` -->
</section>
</section>
<section id="further-rag-discussion">
<h2><span class="section-number">21.8. </span>Further RAG Discussion<a class="headerlink" href="#further-rag-discussion" title="Link to this heading">#</a></h2>
<section id="rag-vs-prompting-and-fine-tuning">
<h3><span class="section-number">21.8.1. </span>RAG vs Prompting and Fine Tuning<a class="headerlink" href="#rag-vs-prompting-and-fine-tuning" title="Link to this heading">#</a></h3>
<p>When adapt an generalist LLM to different usage scenarios, there are different approaches, including direct prompting, fine-tuning, and RAG.</p>
<p>Each method has distinct characteristics as illustrated in <a class="reference internal" href="#chapter-rag-fig-rag-vs-prompt-ft"><span class="std std-numref">Fig. 21.13</span></a>. We used a quadrant chart to illustrate the differences among three methods in two dimensions: <strong>external knowledge requirements and model adaptation requirements</strong>.</p>
<p>From the external knowledge requirement perspective:</p>
<ul class="simple">
<li><p>Prompt engineering leverages a model’s inherent capabilities with minimum necessity for external knowledge and model adaption.</p></li>
<li><p>RAG can leverage external knowledge via information retrieval, making it excellet for knowledge intentsive tasks. For these tasks, indexing stage in RAG often has auto-refresh ability, enabling RAG to provide realtime knowledge updates and effective utilization of external knowledge sources with high interpretability. However, it comes with low latency scenarios, RAG has to spend extra time (~200-500ms) to perform retrieval.</p></li>
<li><p>FT can also be used to inject knowledge. However, the process is expensive in terms of collecting data and conducting training.</p></li>
</ul>
<p>From the model adaptation perspective:</p>
<ul class="simple">
<li><p>Prompt Engineering requires lowest modifications to the model. It is suitable for relative simple tasks without intensive external knowledge. However, the abiity to adapt model is limited to effectiveness of prompt engineering, which is not trivial for some tasks.</p></li>
<li><p>FT is suitable for customizing models to specific structures, styles, or formats. FT allows the model to generate responses to tailored to specific domains; Further, FT on speclialized labeled data can usually further enhance the model performance.</p></li>
<li><p>RAG enjoys the same model adaption flexibility like FT. Specifically, the retriever and generator can be both adapted to specific use cases.</p></li>
</ul>
<figure class="align-default" id="chapter-rag-fig-rag-vs-prompt-ft">
<a class="reference internal image-reference" href="../../_images/RAG_vs_FT_vs_prompt.png"><img alt="../../_images/RAG_vs_FT_vs_prompt.png" src="../../_images/RAG_vs_FT_vs_prompt.png" style="width: 730.4000000000001px; height: 434.40000000000003px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 21.13 </span><span class="caption-text">RAG compared with other model optimization methods in the aspects of <strong>External Knowledge Required</strong> and <strong>Model Adaption Required</strong>.  Image from <span id="id13">[<a class="reference internal" href="#id1549" title="Yunfan Gao, Yun Xiong, Xinyu Gao, Kangxiang Jia, Jinliu Pan, Yuxi Bi, Yi Dai, Jiawei Sun, and Haofen Wang. Retrieval-augmented generation for large language models: a survey. arXiv preprint arXiv:2312.10997, 2023.">GXG+23</a>]</span>.</span><a class="headerlink" href="#chapter-rag-fig-rag-vs-prompt-ft" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In the following, we also summarize different factors to consider when choosing among prompting, fine-tuning, and RAG.</p>
<div class="pst-scrollable-table-container"><table class="table" id="id1565">
<caption><span class="caption-number">Table 21.3 </span><span class="caption-text">Different factors to consider when choosing among prompting, fine-tuning, and RAG.</span><a class="headerlink" href="#id1565" title="Link to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head text-left"><p>Factors</p></th>
<th class="head text-left"><p>Prompting</p></th>
<th class="head text-left"><p>Fine-tuning</p></th>
<th class="head text-left"><p>RAG</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p>Dynamic/up-to-date/private-sourced knowledge</p></td>
<td class="text-left"><p>❌</p></td>
<td class="text-left"><p>✅</p></td>
<td class="text-left"><p>✅</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>Reduce hullucilation</p></td>
<td class="text-left"><p>❌</p></td>
<td class="text-left"><p>❌</p></td>
<td class="text-left"><p>✅</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>Model behavior customization</p></td>
<td class="text-left"><p>❌</p></td>
<td class="text-left"><p>✅</p></td>
<td class="text-left"><p>✅</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>Training cost</p></td>
<td class="text-left"><p>❌</p></td>
<td class="text-left"><p>✅</p></td>
<td class="text-left"><p>✅</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>Explanability</p></td>
<td class="text-left"><p>❌</p></td>
<td class="text-left"><p>❌</p></td>
<td class="text-left"><p>✅</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>General ability</p></td>
<td class="text-left"><p>✅</p></td>
<td class="text-left"><p>❌</p></td>
<td class="text-left"><p>✅</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>Low latency</p></td>
<td class="text-left"><p>✅</p></td>
<td class="text-left"><p>✅</p></td>
<td class="text-left"><p>❌</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="rag-vs-long-context-llm">
<h3><span class="section-number">21.8.2. </span>RAG vs Long Context LLM<a class="headerlink" href="#rag-vs-long-context-llm" title="Link to this heading">#</a></h3>
<p>Long context LLM is one active research area, as enabling long context can open opportunties to handle more complex tasks.
For example, Gemini 1.5 (<a class="reference external" href="https://blog.google/technology/ai/google-gemini-next-generation-model-february-2024/">https://blog.google/technology/ai/google-gemini-next-generation-model-february-2024/</a>) has a context window of 1 million tokens.  This capability makes it possible for long-document question answering, in which user can now incorporate the entire document directly into the prompt.</p>
<p><strong>Do we still need information retrieval component when it comes to long context LLM?</strong> Can we just put a large document as knowledge base in the prompt?
In fact, information retrieval plays an irreplaceable role. Providing LLMs with a large amount of context has the following drawbacks:</p>
<ul class="simple">
<li><p>Inference speed is signficicantly reduced due to long sequences. In comparison,</p></li>
<li><p>The long context usually contain many irrelevant and noisy parts, which will impact the model performance.</p></li>
<li><p>The process is not tracable or explanable.</p></li>
</ul>
</section>
</section>
<section id="bibliography">
<h2><span class="section-number">21.9. </span>Bibliography<a class="headerlink" href="#bibliography" title="Link to this heading">#</a></h2>
<p>Important resources:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://acl2023-retrieval-lm.github.io/">Retrieval-based Language Models and Applications ACL2023 Tutorial</a></p></li>
</ul>
<div class="docutils container" id="id14">
<div role="list" class="citation-list">
<div class="citation" id="id15" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>DZM+22<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id9">1</a>,<a role="doc-backlink" href="#id10">2</a>)</span>
<p>Zhuyun Dai, Vincent Y Zhao, Ji Ma, Yi Luan, Jianmo Ni, Jing Lu, Anton Bakalov, Kelvin Guu, Keith B Hall, and Ming-Wei Chang. Promptagator: few-shot dense retrieval from 8 examples. <em>arXiv preprint arXiv:2209.11755</em>, 2022.</p>
</div>
<div class="citation" id="id1549" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>GXG+23<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id13">2</a>)</span>
<p>Yunfan Gao, Yun Xiong, Xinyu Gao, Kangxiang Jia, Jinliu Pan, Yuxi Bi, Yi Dai, Jiawei Sun, and Haofen Wang. Retrieval-augmented generation for large language models: a survey. <em>arXiv preprint arXiv:2312.10997</em>, 2023.</p>
</div>
<div class="citation" id="id1434" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>NYLC19<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id6">1</a>,<a role="doc-backlink" href="#id7">2</a>)</span>
<p>Rodrigo Nogueira, Wei Yang, Jimmy Lin, and Kyunghyun Cho. Document expansion by query prediction. <em>arXiv preprint arXiv:1904.08375</em>, 2019.</p>
</div>
<div class="citation" id="id20" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>RQH+24<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>)</span>
<p>Dongyu Ru, Lin Qiu, Xiangkun Hu, Tianhang Zhang, Peng Shi, Shuaichen Chang, Jiayang Cheng, Cunxiang Wang, Shichao Sun, Huanyu Li, and others. Ragchecker: a fine-grained framework for diagnosing retrieval-augmented generation. <em>arXiv preprint arXiv:2408.08067</em>, 2024.</p>
</div>
<div class="citation" id="id1552" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>WYQ+23<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id4">1</a>,<a role="doc-backlink" href="#id5">2</a>)</span>
<p>Xintao Wang, Qianwen Yang, Yongting Qiu, Jiaqing Liang, Qianyu He, Zhouhong Gu, Yanghua Xiao, and Wei Wang. Knowledgpt: enhancing large language models with retrieval and storage access on knowledge bases. <em>arXiv preprint arXiv:2308.11761</em>, 2023.</p>
</div>
<div class="citation" id="id1562" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ZPJ+24<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id11">1</a>,<a role="doc-backlink" href="#id12">2</a>)</span>
<p>Tianjun Zhang, Shishir G Patil, Naman Jain, Sheng Shen, Matei Zaharia, Ion Stoica, and Joseph E Gonzalez. Raft: adapting language model to domain specific rag. <em>arXiv preprint arXiv:2403.10131</em>, 2024.</p>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./docs/chapter_rag"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../chapter_prompt/advanced_prompt.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">20. </span>Advanced Prompting Techniques</p>
      </div>
    </a>
    <a class="right-next"
       href="advanced_rag.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">22. </span>Advanced RAG (WIP)</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#motivation">21.1. Motivation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-frameworks">21.2. RAG Frameworks</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-rag">21.2.1. Basic RAG</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimizations">21.2.2. RAG Optimizations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-challenges-in-practice">21.2.3. RAG Challenges in Practice</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-evaluation">21.3. RAG Evaluation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimization-documents">21.4. RAG Optimization: Documents</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#indexing-data-sources">21.4.1. Indexing Data Sources</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#document-parsing">21.4.2. Document Parsing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#data-source-augmentation">21.4.3. Data Source Augmentation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#document-splitting-and-granularity">21.4.4. Document Splitting and Granularity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#document-chunk-relationship">21.4.5. Document Chunk Relationship</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#utilizing-knowledge-graph">21.4.6. Utilizing Knowledge Graph</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#fundamentals">21.4.6.1. Fundamentals</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#challenges">21.4.6.2. Challenges</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimization-query-understanding-and-rewriting">21.5. RAG Optimization: Query Understanding and Rewriting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">21.5.1. Motivation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#approach-to-vocalbulary-mismatch">21.5.2. Approach to Vocalbulary Mismatch</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#approach-to-complex-multi-concept-queries">21.5.3. Approach to Complex Multi-Concept Queries</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#approach-to-multi-turn-conversations">21.5.4. Approach to Multi-Turn Conversations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced-query-categorization">21.5.5. Advanced Query Categorization</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimization-retriever-and-reranker">21.6. RAG Optimization: Retriever and ReRanker</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#retrieval-model-enhancement">21.6.1. Retrieval Model Enhancement</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#retrieval-result-quality-control">21.6.2. Retrieval Result Quality Control</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-optimization-llm-understanding-generation">21.7. RAG Optimization: LLM Understanding &amp; Generation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#motivation-and-objective">21.7.1. Motivation and Objective</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#prompting">21.7.2. Prompting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#model-finetuning">21.7.3. Model Finetuning</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#raft-retrieval-augmented-fine-tuning">21.7.4. RAFT: Retrieval Augmented Fine Tuning</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-rag-discussion">21.8. Further RAG Discussion</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-vs-prompting-and-fine-tuning">21.8.1. RAG vs Prompting and Fine Tuning</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rag-vs-long-context-llm">21.8.2. RAG vs Long Context LLM</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bibliography">21.9. Bibliography</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Yuguang Yang
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>